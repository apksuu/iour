name: Telegram Bot VM (5 Hours) - Realtime Output

on: 
  workflow_dispatch:

jobs:
  run-vm:
    runs-on: ubuntu-latest
    steps:
      - name: âš™ï¸ è®¾ç½® Python ç¯å¢ƒ
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: ğŸ“¦ å®‰è£…ä¾èµ–åº“
        run: pip install python-telegram-bot nest_asyncio

      - name: ğŸ¤– å¯åŠ¨ Telegram æ§åˆ¶ç«¯ (å¼‚æ­¥æµå¼è¾“å‡º)
        run: |
          cat << 'EOF' > bot.py
          import asyncio
          import subprocess
          import sys
          import os
          from telegram import Update
          from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, filters, ContextTypes

          TOKEN = '8310173625:AAGjhP7DOW-xpad6W5UUVNb0g0VC70D6ww4'

          async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
              welcome_msg = (
                  "âœ… è™šæ‹Ÿæœºå·²è¿æ¥ (å¼‚æ­¥è¾“å‡ºæ¨¡å¼)ã€‚\n"
                  "æ”¯æŒ `cd` ç›®å½•è®°å¿†ï¼Œå‘½ä»¤æ‰§è¡Œç»“æœå°†å®æ—¶åˆ·æ–°ã€‚\n\n"
                  "â³ è¿è¡Œæ—¶é•¿ä¸Šé™ï¼š5å°æ—¶\n"
                  "ğŸ›‘ è¾“å…¥ /stop é”€æ¯å®ä¾‹ã€‚"
              )
              await update.message.reply_text(welcome_msg)

          async def stop(update: Update, context: ContextTypes.DEFAULT_TYPE):
              await update.message.reply_text("ğŸ›‘ æ­£åœ¨ç»“æŸè¿›ç¨‹å¹¶é”€æ¯è™šæ‹Ÿæœº...")
              sys.exit(0)

          async def handle_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
              cmd = update.message.text.strip()
              
              # æ‹¦æˆªå¤„ç† cd å‘½ä»¤
              if cmd.startswith("cd "):
                  target_dir = cmd[3:].strip()
                  try:
                      os.chdir(target_dir)
                      await update.message.reply_text(f"ğŸ“ å½“å‰å·¥ä½œç›®å½•å·²åˆ‡æ¢è‡³:\n{os.getcwd()}")
                  except Exception as e:
                      await update.message.reply_text(f"âŒ ç›®å½•åˆ‡æ¢å¤±è´¥: {str(e)}")
                  return

              sent_msg = await update.message.reply_text(f"ğŸ’» æ‰§â¾: `{cmd}`\nâŒ› æ­£åœ¨åˆå§‹åŒ–å­è¿›ç¨‹...")
              
              try:
                  # ä½¿ç”¨ asyncio åˆ›å»ºå­è¿›ç¨‹ï¼Œå®ç°éé˜»å¡æ‰§è¡Œ
                  process = await asyncio.create_subprocess_shell(
                      cmd,
                      stdout=asyncio.subprocess.PIPE,
                      stderr=asyncio.subprocess.PIPE,
                      cwd=os.getcwd()
                  )

                  full_output = ""
                  last_sent_output = ""
                  
                  # å®šä¹‰è¯»å–è¾“å‡ºæµçš„åç¨‹
                  async def read_stream(stream):
                      nonlocal full_output
                      while True:
                          line = await stream.readline()
                          if not line:
                              break
                          full_output += line.decode('utf-8', errors='replace')

                  # å¹¶å‘è¯»å– stdout å’Œ stderr
                  task_out = asyncio.create_task(read_stream(process.stdout))
                  task_err = asyncio.create_task(read_stream(process.stderr))

                  # åœ¨å­è¿›ç¨‹è¿è¡Œæ—¶ï¼Œå®šæ—¶åˆ·æ–° Telegram æ¶ˆæ¯
                  while not task_out.done() or not task_err.done():
                      await asyncio.sleep(1.5) # æ§åˆ¶åˆ·æ–°ç‡ï¼Œç¬¦åˆ Telegram API é™åˆ¶
                      
                      display_text = full_output[-3800:] # æˆªå–å°¾éƒ¨æ•°æ®ï¼Œé˜²æ­¢è¶…é•¿
                      if display_text != last_sent_output and display_text.strip():
                          try:
                              await sent_msg.edit_text(
                                  f"ğŸ’» æ‰§â¾: `{cmd}`\n\nğŸ“„ å®æ—¶è¾“å‡º:\n```\n{display_text}\n```", 
                                  parse_mode='Markdown'
                              )
                              last_sent_output = display_text
                          except Exception:
                              pass # å¿½ç•¥å†…å®¹æœªæ”¹å˜å¯¼è‡´çš„ API æŠ¥é”™

                  await process.wait()
                  await task_out
                  await task_err

                  # è¿›ç¨‹ç»“æŸåå‘é€æœ€ç»ˆçŠ¶æ€
                  final_text = full_output if full_output.strip() else "[æ‰§è¡Œå®Œæ¯•ï¼Œæ— æ ‡å‡†è¾“å‡º]"
                  await sent_msg.edit_text(
                      f"âœ… æ‰§è¡Œå®Œæˆ: `{cmd}`\n\nğŸ“„ æœ€ç»ˆç»“æœ:\n```\n{final_text[-3800:]}\n```", 
                      parse_mode='Markdown'
                  )

              except Exception as e:
                  await sent_msg.edit_text(f"âŒ è¿è¡Œæ—¶å¼‚å¸¸: {str(e)}")

          async def main():
              app = ApplicationBuilder().token(TOKEN).build()
              
              app.add_handler(CommandHandler("start", start))
              app.add_handler(CommandHandler("stop", stop))
              app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_command))
              
              print("æœåŠ¡å·²å¯åŠ¨ï¼Œç­‰å¾…æŒ‡ä»¤...")
              await app.initialize()
              await app.start()
              await app.updater.start_polling()
              
              # ç»´æŒ 5 å°æ—¶ç”Ÿå‘½å‘¨æœŸ (18000ç§’)
              await asyncio.sleep(18000)
              
              print("è§¦å‘ 5 å°æ—¶ç”Ÿå‘½å‘¨æœŸé™åˆ¶ï¼Œæ‰§è¡Œæ¸…ç†ç¨‹åº...")
              await app.updater.stop()
              await app.stop()
              await app.shutdown()

          if __name__ == '__main__':
              asyncio.run(main())
          EOF
          
          python bot.py
